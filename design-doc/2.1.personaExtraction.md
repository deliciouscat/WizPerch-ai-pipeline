## 태도, 정보, 행동

`f(태도, 정보) = 행동`  
태도 = 저장된 persona / 정보 = 페이지 / 행동 = 댓글
- `태도`는 상수로 생각.
- 어플리케이션은 `정보`를 제어할 수 있다.
- `행동`은 댓글 등으로 관측할 수 있다.
- 링크 클릭은 `태도`의 관측으로 볼 수 있다.

DB에 저장되어야 하는 정보는 `태도`이다.
`태도` 정보의 추상화 수준(요약 ~ 구체적)이 구체적일수록 정확한 `행동` 예측
- g = 주제에 대한 사용자의 태도를 추출.
- A = DB에 저장되어 있는 태도
- B = g(주제, 정보, 행동) = 방금 추출해낸 태도
라고 할때, `행동`과의 일치도는 `f(A+B, 정보)` > `f(A or B, 정보)` 여야겠다.  

`f(A+B, 정보)` < `f(A, 정보)`인 상황: 새로운 태도(B)의 추출이 잘못됨.  
`f(A+B, 정보)` < `f(B, 정보)`인 상황: 기존 태도 정보(A)에 잘못된 부분이 있음.  
기존 태도 정보(A)는 아무리 길어도 상관 없다는 조건을 충족해야 함(`저장 용량관리를 의한 축소`가 `컨텍스트 관리를 위한 축소`보다 먼저 일어나야 함.)

! 지금 최적화해야 하는건 `f`(프롬프트)가 아니라 태도 정보임 !  

B를 추출해내는 프로세스(프롬프트, 파이프라인) 개선을 위한 과정
```
1. 아래를 각각 실행:
f(A+B, ~)
f(A, ~)
f(B, ~)

2. 실제 댓글과 비교하여 얼마나 댓글을 잘 예측했는지를 확인.
f(A+B) < f(A) -> B를 추출하는 프롬프트를 개선
f(A+B) < f(B) -> 저장된 A에서 잘못된 부분이 있는지 확인. ('충돌되는 부분' 추출) -> 충돌 없으면 수정 안해도 됌 있으면 수정

3. 다중 batch로 위의 프로세스를 돌려서 6개 정도의 `g` 프로세스 진화를 관측하자.
```

### Painpoint

`f`가 numeric한 output을 내놓는다고 설정했을 때, 그 수치를 신뢰할 수 있을지?  
`f`가 서술의 형태로 output되면 유사도 비교라는 행위를 할 수 있을지?  
-> string match, 가벼운 BERT similarity
-> '충분히' 가벼운 similarity 모델은 다른 task에도 쓸 수 있는 모델을 골라야 할 듯.


## 웹 추천 시스템과의 상호보완성

- persona 추출은 `f(태도, 정보) = 행동` 이라는 전제하에 구성됨
- Knowledge tracing을 기반으로 한 추천은 `f(정보, 기존행동) = 태도` 라는 전제 하에 구성됨.

iterative하게 태도가 변화할 수 있다는 점 반영되어야.